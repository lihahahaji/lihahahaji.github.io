import{_ as h,r as p,o as u,c as _,a as s,b as t,d as a,w as n,e as r}from"./app-d1c0f0b2.js";const d={},g=s("h1",{id:"rrt",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#rrt","aria-hidden":"true"},"#"),t(" RRT*")],-1),f=s("p",null,"RRT*是基于RRT算法的扩展版本。RRT*的目标是在考虑路径质量的同时，有效地搜索从起点到目标点的最优路径。",-1),R=s("p",null,"RRT 和 RRT-Connect 算法都是无法找到最优的路径的",-1),v=s("blockquote",null,[s("p",null,"关键点:"),s("p",null,"与 RRT 算法主要的不同点主要在树拓展的过程中有一个重连操作(4. 路径优化).")],-1),x=s("p",null,"算法步骤：",-1),y=s("li",null,[s("p",null,[s("strong",null,"初始化"),t("：与RRT相似，RRT*算法开始时创建一个包含起点的树，只有一个节点。")])],-1),w=s("li",null,[s("p",null,[s("strong",null,"随机采样"),t("：从配置空间中随机生成一个点，通常是一个潜在的目标点或一些离散的点。这个点用于扩展当前的树。")])],-1),T=s("li",null,[s("p",null,[s("strong",null,"树扩展"),t("：选择当前树中距离随机采样点最近的节点，然后尝试沿着连接这个节点和随机采样点的路径来扩展树。与RRT不同，RRT*会考虑到已经生成的路径，以确保新的路径是最优的。")])],-1),b=s("p",null,[s("strong",null,"路径优化"),t("：在路径扩展后，RRT*会检查新路径与其它路径的交叉点。如果发现更短的路径，RRT*会更新树中的节点和路径，以反映出这个改进。这个步骤是RRT*的另一个关键特性，也就是"),s("strong",null,"重连"),t(",它有助于寻找更接近最优解的路径。")],-1),k=s("p",null,"重连的具体操作:",-1),z={class:"katex"},M={class:"katex-mathml"},X=r('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span>',1),L={class:"katex"},N={class:"katex-mathml"},V=r('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span>',1),B={class:"katex"},C={class:"katex-mathml"},q=r('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span>',1),E={class:"katex"},S={class:"katex-mathml"},j=r('<span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span>',1),A=s("p",null,[s("img",{src:"https://img-blog.csdnimg.cn/img_convert/01fc87ff2295932aaba3c594abb21728.png",alt:"img"})],-1),D=s("li",null,[s("p",null,[s("strong",null,"重复"),t("：不断重复随机采样、树扩展和路径优化步骤，直到达到一定条件，比如找到一条最优路径或达到最大迭代次数。")])],-1),F=s("li",null,[s("p",null,[s("strong",null,"路径回溯"),t("：如果在树的扩展过程中找到了一条最优路径，就可以通过回溯树中的节点来提取这条路径。")])],-1),G=s("p",null,"RRT*的关键优势在于它能够有效地搜索高维配置空间中的最优路径，而且能够在不断探索的同时改进已经找到的路径(重连)，使其趋近于最优。",-1);function H(I,J){const l=p("mi"),e=p("mrow"),i=p("msub"),m=p("annotation"),o=p("semantics"),c=p("math");return u(),_("div",null,[g,f,R,v,x,s("ol",null,[y,w,T,s("li",null,[b,s("blockquote",null,[k,s("p",null,[t("在将新节点"),s("span",z,[s("span",M,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:n(()=>[a(o,null,{default:n(()=>[a(e,null,{default:n(()=>[a(i,null,{default:n(()=>[a(l,null,{default:n(()=>[t("X")]),_:1}),a(e,null,{default:n(()=>[a(l,null,{default:n(()=>[t("n")]),_:1}),a(l,null,{default:n(()=>[t("e")]),_:1}),a(l,null,{default:n(()=>[t("w")]),_:1})]),_:1})]),_:1})]),_:1}),a(m,{encoding:"application/x-tex"},{default:n(()=>[t("X_{new}")]),_:1})]),_:1})]),_:1})]),X]),t("加入树的过程中, RRT 算法会直接选择距离这个新节点最近的节点"),s("span",L,[s("span",N,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:n(()=>[a(o,null,{default:n(()=>[a(e,null,{default:n(()=>[a(i,null,{default:n(()=>[a(l,null,{default:n(()=>[t("X")]),_:1}),a(e,null,{default:n(()=>[a(l,null,{default:n(()=>[t("n")]),_:1}),a(l,null,{default:n(()=>[t("e")]),_:1}),a(l,null,{default:n(()=>[t("a")]),_:1}),a(l,null,{default:n(()=>[t("r")]),_:1})]),_:1})]),_:1})]),_:1}),a(m,{encoding:"application/x-tex"},{default:n(()=>[t("X_{near}")]),_:1})]),_:1})]),_:1})]),V]),t("作为父节点. 而在 RRT*算法中, 通过父节点找到新节点"),s("span",B,[s("span",C,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:n(()=>[a(o,null,{default:n(()=>[a(e,null,{default:n(()=>[a(i,null,{default:n(()=>[a(l,null,{default:n(()=>[t("X")]),_:1}),a(e,null,{default:n(()=>[a(l,null,{default:n(()=>[t("n")]),_:1}),a(l,null,{default:n(()=>[t("e")]),_:1}),a(l,null,{default:n(()=>[t("w")]),_:1})]),_:1})]),_:1})]),_:1}),a(m,{encoding:"application/x-tex"},{default:n(()=>[t("X_{new}")]),_:1})]),_:1})]),_:1})]),q]),t("之后, 不会直接将这个节点作为新节点的父节点, 而是在树中重新寻找一个节点"),s("span",E,[s("span",S,[a(c,{xmlns:"http://www.w3.org/1998/Math/MathML"},{default:n(()=>[a(o,null,{default:n(()=>[a(e,null,{default:n(()=>[a(i,null,{default:n(()=>[a(l,null,{default:n(()=>[t("X")]),_:1}),a(e,null,{default:n(()=>[a(l,null,{default:n(()=>[t("m")]),_:1}),a(l,null,{default:n(()=>[t("i")]),_:1}),a(l,null,{default:n(()=>[t("n")]),_:1})]),_:1})]),_:1})]),_:1}),a(m,{encoding:"application/x-tex"},{default:n(()=>[t("X_{min}")]),_:1})]),_:1})]),_:1})]),j]),t(", 使得从起点移动到新节点的路径代价最小.")]),A])]),D,F]),G])}const O=h(d,[["render",H],["__file","RRT_.html.vue"]]);export{O as default};
